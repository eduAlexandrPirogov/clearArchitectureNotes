

# Улучшение уровня реализации:

------------------------------

1. Избавляемся от методов, которые используются только в тестах

Пример 1.

Имеется класс А, которые отвечает за расчет финансов для сервисов. 
Имеется несколько типов финансов, и для каждого типа финансов у каждого сервиса свой показатель.
Типы финансов рассчитываются последовательно, то есть, рассчитывается финанс ф1, потом ф2 и так до фn. 
Поскольку класс А изначально не имел get/set (старался их не использовать), то создал наследника А класс Б, в котором определил данный метод,
который используется только в тестах.

```php

class FinancesCalculator
{
   protected $finances;
}

class FinancesCalculatorFotTests extends FinancesCalculator
{
  
   publc function getFinances()
   {
       return $this->finances;
   };
}


//Тесты для финансов
public function test_finances_equality()
{
    $finances = $bInstance->getFinances();
    //Проходим весь многомерный массив и проверяем несколько вещей, нарушая SRP
    ...
};


public function test_finances_values()
{
    $finances = $bInstance->getFinances();
    //Проходим весь многомерный массив и проверяем несколько вещей, нарушая SRP
    ...
};
```

Мы хотели бы добраться до содержимого поля $finances, при этом не устанавливая методы get/set. Плюс постоянный проход по многомерному массиву не лучшая идея.

Тут можно поступить следующий образом:
1. Для каждого типа финанса создаем класс
2. Каждый тип финанса будет рассчитывать результат для каждого сервиса, полученного в конструкторе.
3. Результат будет записываться в массив, который передается по ссылке.

```php
class oborot
{
    private $oborotFinances; //map
    
    public function __contrsut(array $service)
    {
       ...
    };
    
    public function calculate()
    {
       ...
    };
    
    public function writeResult(array& $toArray)
    {
        foreach($this->oborotFinances as $finances)
            $toArray = ...;
    };
};

class costprice
{
     private $oborotFinances; //map
    
    public function __contrsut(array $service, doube $startValue)
    {
       ...
    };
    
    public function calculate()
    {
       //свой метод расчета
    };
    
    public function writeResult(array& $toArray)
    {
        foreach($this->oborotFinances as $finances)
          $toArray = ...;
     };
};

//И так далее
```

Несмотря на то, что классов станет у нас больше, но они будут небольшими. Методы используются не только в тестах. Если подумать, можно создать иерархию
из типов финансов, чтобы полиморфно вызывать объекты из контейнера, но в проекте это не потребовалось.
Теперь для каждого класса имеется свой тест, который будет проверять только то, что ему нужно, не проходя весь массив. Также тесты будут проверять только одну вещь.

----------------------

2. Избавляемся от цепочки вызовов.


Имеется класс MyString в рабочем проекте с методами для обработки строк. Класс замыкается относительно себя, так как почти все методы возвращают
MyString. И в коде встретилась такая ситуация:

```php
public function rewrite_rules()
{
    //...
    $data = new MyString($this->str);
    $data->trim_backlash()->set_underscope()->to_upper()->to_json();
    //...
};
```
Несмотря на то, что класс MyString в методах возвращает MyString, лучше избавиться от цепочек методов.
Например, можно создать метод create_json(MyString $string), где мы вынесем соответствующие методы:

```php
public function create_json(MyString $string)
{
    $string = $string->trim_backslash();
    $string = $string->set_underscope();
    $string = $string->to_upper();
    $string = $string->to_json();
    return $strung;
};
```

Подобные цепочки возможно будут оправданы если:
1. Класс замыкает сам себя
2. Операции класса идемпотентны (от перестановки операций результат не изменится).

Какие тут плюсы:
1. Мы вынесли внутреннюю кухню в отдельный метод, нам не нужно знать, что он делает.
2. Явная видимость, какой объект работает за что ответственный.

Пример 2.
Второй пример больше теоретически, так как не нашел подходящий пример.
Допустим, мы работаем со следующим методом:

```
//Изначально
class foo
{
   
   public function bar()
   {
       return $list->getItem()->increase()->toString()->toUpper();
   };
}

//Подробнее
//В данном методе встречаются 3 разных объекта! И класс должен знать о них!
public function bar()
{
   List $list = new List();
   Item $item = $list->getItem(0);
   $item = $item->increase();
   String $str = $item->toString();
   return $str->toUpper();
};
```

Как можно исправить:

Тут стоить действовать по принципу "держи свой близких ближе". То есть класс foo должен знать только о List. List, в свою очередь, знает только об
классе Item и так далее.
В данном случае, можно сделать следующим образом:

```
//Изначально
class foo
{
   
   public function bar()
   {
      List $list = new List();
      return list->getUpperItem(0);
   };
}

class List
{
   //Выносим всю кухню в отдельный метод
   public functino getUpperItem($index)
   {
       return $this->item[0]->toUpper();
   }
   
};
```

Или же возвращать item, и с помощью класса String и метода toString($item)->toUpper сделать то что нужно.
Посыл основной такой:
Класс как можно меньше должен знать о системе/внешнем мире.

----------------------

3. У методя слишком много параметров

Пример 1.
Имеется класс, который просто сохраняет данные в csv/xls файл и использует слишком большое количество параметров.

```php
class DataSaver
{
   public function saveData($file, $header, $delimeter, $escape_character, $enclosure, $format)
   {
      //Настройка файла и запись
   };
}
```

Прежде чем упрощать метод, следует понять, что за типы данных используются в методы. file -- это имя или класс? header -- булево значение или нет?
Изучив код, пришел к следующему:
```php

   public function saveData(string $filename, Header $header, string $delimeter, string $escape_character, string $enclosure, string $format)
   {
      //Настройка файла и запись
   };
```

Разбиваем постепенно:
1. последний параметр string $format можно вынести в отдельные методы. То есть будет метод saveDataCsv, saveDataXls
2. Первые два параметра можно вынести в конструктор, они будут полуями класса.

Итого у нас останется 3 параметра, клиент класса которого волен избирать:

```php
class DataSaver
{

   private $fileName;
   private $header;
   
   public function __construct(string $filename, Header $header)
   {
      $this->filename = $filename;
      $this->header = $header;
   };
   
   public function saveDataCsv($delimeter, $escape_character, $enclosure)
   {
      //Настройка файла и запись
   };
   
     public function saveDataXls($delimeter, $escape_character, $enclosure)
   {
      //Настройка файла и запись
   };
}
```
Таким образом:
1. Класс имеет теперь поля.
2. Класс имеет методы, которые соответствуют единой спецификации (записать тот или иной формат).

В случае, если метод использует слишком много параметров, то я обычно следую так:
1. Если имеется параметр, который явно подразумевает небольшое множество, перечисление (Как в случае с форматом), то выношу в отдельный метод
2. Изучаю, какие параметры можно вынести в поля класса. За счет этого, проверку можно делать в конструкторе на корректность данных, и метод, который
мы упростили, занимается одной вещью
3. Если параметров остается больше 3-х штук, разбиваю класс на классы.

------------------------

4. Вынесенеие единого функционала из нескольких методов в единый

Пример 1.

В одном из рабочий проектов, который разрабатывают несколько разработчиков, каждый создавал свой метод для обработки строк. Выполняли методы примерно
один и тот же функционал, но отличались сигнатурой. 
То есть было несколько классов String-подобных:

```php
class String
{
   public function delete_characters($data, array $characters_to_delete)
   {
        ...        
   };
   
   //...
};

class StringHelper
{
   public function trim_backlash($data)
   {
       ...
   };
   
   //...
};
```

Из-за чего иногда приходилось создавать два инстанса класса, чтобы решить "обработать" строку.

В данном случае просто создаем класс-обертку для базового типа и определяем для него методы:

```php
//Создаем единый класс
class String
{
   private $buffer;
   public function __construct($data)
   {
      $this->buffer = $data;
   };
   
   public function trim_backlash()
   {
       ...
   };
   
   public function delete_characters(array $characters_to_delete)
   {
        ...        
   };
   
   //....
};
```
Тем самым мы избавились от неоднозначности, имеется единственный АТД, с которым проще работать. Но имеется минус, что такой АТД монолитный, так как для строк можно придумать множество операций.

--------------------------

5. Метод возвращает слишком много :)

Пример 1.
Приведен в пунтке 2, когда метод возвращает многомерный массив и, чотбы провести тест, приходится проходить весь массив.
Решается проблема также, как и в пунтке 2.


Пример 2.

Распространенная на работе ситуация, когда обрабатывают некий многомерный объект, но возвращают его часть:

```php
public function update_params($param)
{
   $json = getRules();
   
   //идет обработка jsona
   
   return $json["key"]
};
```
Тут все довольно просто:

```php
public function update_params($param, $key)
{
   $json = getRules($key);
   
   //идет обработка jsona
   
   return $json["key"]
};
```

Основной посыл следующий:
1. Если возвращаете многомерный объект, а нужна только его часть, то возвращайте только эту часть (по запросу).
2. Если хотите обработать часть многомерного объетка, то работайте только с этой частью. 


-------------------------
Подобные моменты имеют место быть постоянно, и, несмотря на то, что они вроде как "мелочь", мы работаем по методике "Разделяй и Властвуй", то следствие этой методики, что мы работаем с мелочью и мелочи эти важны. 
