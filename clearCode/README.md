Ясный-код 2

## 2.1
Прежде чем говорить, почему создание много инстансов класса -- плохой признак, стоит сказать, что есть ситуации, когда это нормально. Например, класс String. Это может служить:
1. Как хорошо спроектированный класс
2. Класс выполняет роль "обертки" некого типа данных. Да, тут можно дискутировать на тему, "Как много должен делать класс MyString над строками", но сейчас не об этом.

Теперь рассмотрим ситуацию, когда создание слишком большого числа инстансов -- плохая идея. Прежде всего, на что
стоит обратить внимание -- это контекст. Мы можем создавать больше количество инстансов класса String, но контекст у него будет один -- работа со строками. 
Если мы создаем какой-то класс в разных частях кода, то стоит определить, в каком контексте мы используем его в разных частях этих. Контекст определяется (по моему мнению) по методам, который вызывает новосозданный инстанс в той или иной части кода. 
Зачастую встречаются в проекте классы "Helper'ы", которые выступают в качестве интрумента-помощника. Причем, туда можно напихать разных методов, с аргументом на то, что "ну класс Helper служит для помощи". 

```
class Helper
{
     public function plusDate(Date $date);
     public function strToDate($format, $str);
     ...
}
```
И вызовы подобных Helper'ов могут быть в разных частях кодах, но в одной части, чтобы преобразовать строку в дату, а в другой части кода -- прибавить дату.

## 2.2
"Маленький классы", которые я встречал:
1. классы, у которых имеется геттер и один метод. 
2. struct-подобные классы

Например, в рабочем проекте был такой класс:

```php
class FileConverter
{
  private $file;
    public function convertFile($toFormat)
    {
      $this->file->convert($toFormat);
      ....
      return $this->file.
    }
};
```
Скорее, этот метод можно отнести к классу FileWorker, которые будет взаимодействовать с файлами. Но опять же,
как в случае 2.1 инстансы этого класса могут создаваться в разных частях кода.

## 2.3

Первый случай -- 2.2.
Второй случай: паттерн "Наблюдатель". Например, имеется контейнер и мы хотели бы получить некие агрегированные
данные, например сумму элементов. Но засорять подобными методами класс не хотелсь бы.
Тут можно применять паттерн "Наблюдатель", которые будет содержать в себе подобные методы.
Ну или можно создать итератор-агрегатор, в который уйдет соответствующий аггрегирующий метод.


## 2.4
Не встречал еще подобного, но скорее возможна ситуация, когда некий объект передается по цепочке методов по ссылке, и на пути ему "доставляются" данные.
Такая ситуация возможна, когда наследуемся от определенного класса, в который заносятся данные посредством метода М, но мы также добавляем метода М2, который заносит в текущий класс иные данные. И в какой-то части кода мы вызываем метода М, а через цеопчку вычислений вызываем М2.


## 2.5
Была ситуация на работе следующая. Класс FinanceCorrection запрашивал у класса TurnoverHandler текущее состояние рассчета и в зависимости от результата вызывал нужный метод. То есть выглядело это следующем образом:

```php
function correctTurnover($turnoverInstance)
{
    $financeCorrection = new FinanceCorrection();
    if($turnoverInstance->getSuccessOperationStatus() == "OK")
    {
         $result = $turnOverInstance->method1();
    } else if ($turnoverInstance->getSuccessOperatioStatus() == "DELAYED")
    {
        $result = $turnOverInstance->method2();
    } ...
}
```

То есть $finanCorrection должен быть сначала взять внутренние поля инстанса $turnoverInstance, а затем в зависимости от значения, вызывал нужный метод, то есть класс-клиент понимал, что реализация класса $turnoverInstance заточена и зависит на значения внутреннего поля.



## 2.6
Ситуация, что мы хотим создать дерево папок в ОС. У нас есть файлы и директории, содержащие файлы. 
Одна из реализций моей была классов File от которого наследуется Direcrory с методом add(File) и содержал контейнер, для хранение указателей на File. 
При итерации дерева, приходил приводить File к Directory через dynamic_cast, чтобы достать нужные методы Dir:

```cpp
for(const auto* file : files)
  Directory* dir = dynamic_cast<Directory*)(file);
```


## 2.7 
Параллельная иерархия классов. Частая встречаемая ситуация в паттернах, например Паттерн "Мост", который отделяет абстракцию от реализации. 
В книге GOF приводится пример с окнами и иконками, когда нужно создавать для каждой иконки свою реализацию. С одной стороны это дает гибкость, но больше влечет за собой негативный моменты.

Например, следуюя книге"Алгоритмы. Руководство по разработке" Скиена, то АТД для структур данных будет следующим:
1. найти элемент
2. добавить элемент
3. удалить элемент

И, следуя параллельной иерархии, мы можем создать интерфейс "Структура Данных", и для каждого предка создавать реализацию. Проблема заключается в том,
что нам, скорее всего, придется переопределять методы. Например, определим класс "Список" и наследуем его от "Структура Данных". Создаем соответствующую параллельную реализацию.
Если мы захотим создать класс "Двунаправленный список", то тут возникает вопросы:
1. Наследуемся ли мы от класса "Список", тем самым на придется переопределять методы
2. Наследуемся ли мы от класса (точнее говоря реализуем) "Структура данных" тем самым мы повторяем бОльшую часть кода написанную в классе "Список". 


## 2.8
Ситуация, когда дочерние классы переопределяют методы возникает чаще всего при 3-4 уровне иерархий классов.
В С++ есть идиома, чтобы создавать как можно позже реализацию класса, а до этого только абстрактные классы.

Опять же ситуация с паттернами проектирования, паттерн "Шаблонный Метод".

Если обратимся к примеру из книги "Паттерны Проектирования" Фрименов, то для "Шаблонного метода" представлена ситуация, когда мы готовим некий напиток, и имеется алгоритм/шаблон приготовления напитка, но для разных напиткой разная ситуация.

И в качестве решения проблемы, создают класс с определенными методами:

```
class Cooking
{
   protected funcion prepare();
   protected function boil();
   protected function addIncridients();
   
   public function cook()
   {
       prepare();
       boil();
       addIncgridients();
   };
}
```

По задумке, некоторые методы могут быть реализованы, а мы наследуемся и реализуем свои идеи.
Проблема заключается в том, что:
1. У нас есть абстрактный класс А у которого реализовано 0 методов (допустим, это будет множество методов {m1,m2,m3,m4}.
2. У нас есть абстрактный класс Б, который реализует методы m1, m2.
3. Мы наследуем класс В от Б и реализуем методы m3,m4. 

Вроде все просто, но могут возникнуть ситуации, когда мы хотим создать класс, у которого будет реализованы методы m2, m4, но нам:
1. Либо наследоваться от самого верхнего класса и повторять часть кода
2. Либо наследоваться от набиолее подходящего класса, где придется переопределять меньшее количество методов.

======================
3.1
Данный случай есть следствие случая 2.1. Если у нас есть класс, инстансы которого создаются повсеместно, то изменив параметры методы класса (если не поддерживается multiple dispatch) неизбежно приведет к тому,что нужно соответствующие изменения внести в остальные части кода.
То есть, допсутим есть класс из примера 2.1:
```
class Helper
{
     public function plusDate(Date $date);
     public function strToDate($format, $str);
     ...
}
```

И нам нужно добавить параметр в plusDate наскольку мы хотим увеличить дату. Тут либо создавать метод с другим
названием и другими параметрами, либо изменять повсемесстный код. 
Либо же возможна ситуация, когда метода возвращает другой класс. Тогда, в частях кода, где используются данные методы, придется подключать пакеты/хедеры с данными классом, изменять код в разных частях.

3.2
Первый случай: использование паттерна наблюдатель, когда можно использовать обычный итератор. Через итератор "Уведомляем" объекты".
Второй случай: На работе бы случай, когда для использования Rabbit'аMQ использовался паттерн Builder, и в инстанс Rabbit'aMQ заносились параметры подключения, когда можно было использовать environment-file. 
