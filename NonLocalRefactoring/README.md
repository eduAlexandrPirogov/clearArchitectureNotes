# Нелокальные изменения проекта

Сначала описывается "первичный" вариант проекта и как к нему пришли. Далее описываются изменения проекта.

1. Первый пример.

Как было изначально: имеется проект, который занимается прогнозированием финансовых показателей сервисов. Сервисы распределены по двум БД -- назовем их А и Б.
Из этих БД берутся некоторые входные данные. Также имеются алгоритмы для прогнозирования того или иного сервиса. При расчете прогнозизования финансовых показателей,
финальный результат помещался в таблицу.
Но имеется общий алгоритм для формирования результата и назовем его Ф_ОБЩИЙ_ПРОГНОЗ:
1. Посчитать финанса Ф1. 
2. Посчитать финансы Ф2.
3. Посчитать финансы Ф3.
4. Посчитать финансы Фn и вывести результат.

Архитектура и дизайн приложения выглядел следующим образом:
1. Берем актуальные сервисы из БД.
2. Берем входные данные для сервисов.
3. К каждому сервису применяется определенный алгоритм. Возможна ситуация, когда для некоторых сервисов нужно было брать дополнительные данные из БД.
4. Выводим результат в финальную таблицу.

Изначально было несколько PL/SQL функций, которые рассчитывали финансовые показатели. Затем, по мере того, как добавлялись новые сервисы и новые спецификации
по прогнозированию, код был перенесен на PHP. 
В PHP алгоритм был следующий: класс Service имел метод для рассчета финансов. При этом, по мере развития проекта, были созданы множество Helper-подобных классов,
которые помогали рассчитывать показетели по изощренным алгоритмам.
Стоит сказать, что многие сервисы имели похожий алгоритм для рассчета, а некоторые -- совершенно отличающиеся. Т.е. общий алгоритм прогнозирования один, но как высчитываются
промежуточные данные (промежуточные алгоритмы) могут координально отличаться.
Стоит сказать, что используемая БД -- Postgres, и будь там пакеты, как в Oracle MySQL, то можно было бы просто расскидать функции по пакетам.

В итоге, часть кода была на PL/SQL, часть кода в PHP, и все довольно тяжело поддерживается.


Как можно изменить:
 
Во-первых выделим трудности проекта:
1. Часть кода, которая по-смыслу выполняют одну работу, разбросана в PL/SQL и в PHP, из-за чего сложнее поддерживать проект.
2. Код имеет множества недоклассов, которые нужно только для единичных случаев. (MathHelper, DateTimeHelper, SQLHelper и т.д.)
3. Забор данных из БД может происходить в разных момент (то есть в процессе рассчета), что, как мне кажется, не есть хорошо.

Тут, на мой взгляд, хорошо бы подошла функциональная парадигма:
1. У нас имеется общий алгоритм прогнозирования -- Ф_ОБЩИЙ. Можно создать функцию finance_forecast.
2. finance_forecast состоит из несколький шагов Ф, для каждого из которого имеется своя функция calculate_finance_type1.

Выглядит примерно следующий образом:
```php
//$service -- соответствующий сервис
//$listOfFunctions -- список лямбда-функций, которые нужны для вычислений.
const $servicesFunctions = (1, array($lambda1, $lambda2...));

function calculate_forecast($servicesFunctions)
{
    calculate_finance_type1($service, $listOfFunctions[0]);
    calculate_finance_type2($service, $listOfFunctions[1]);
    ...
    calculate_finance_typen($service, $listOfFunctions[n-1]);
};
```
Далее, создадим для функции для рассчета непосредственно финансов для каждого шага. Тут стоит мыслить не "как данный сервис рассчитывается финансы на шаге Фk',
а "какие алгоритмы имеются для рассчета финансов". 

Создаем модуль/директорию/иерархию "FinanceAlgorithms". Самый "верхний" уровень будет следующим:

```php

namespace FinanceAlgorithms;

  function calculate_finance_type1($input_data, $lambdaHowToCalc)
  {

  };

  function calculate_finance_type2($input_data, $lambdaHowToCalc)
  {

  };

//...
```

Далее, мы создаем непосредственно функции $lambdaHowToCalc. Выглядеть финальный результат будет следующим образом:
```php
//Получаем все данные из БД, заносим их в const переменные. Далее создает $serviceFunctions.
const $servicesFunctions = (1 => $calculateForService1($someFunction($someArg1, $someArg2)),
                            2=>...);
    
function calculate_forecast($service, $listOfFunctions)
{
    calculate_finance_type1($service, $listOfFunctions[0]);
    calculate_finance_type2($service, $listOfFunctions[1]);
    ...
    calculate_finance_typen($service, $listOfFunctions[n-1]);
};

foreach($servicesFunctions as $service => function)
{
  calculate_forecast($service, $function);
}

```

Таким образом:
1. Мы уберем функции из PL/SQL. У нас будет храниться рассчет в едином месте.
2. Сокращена кодовая база на 7-10 классов (хелперы нам не нужны, для этого есть функции).
3. Довольно гибкая архитекута (для рассчета нового сервиса добавляем новую функцию).
4. Легко тестировать.

Но тут имеются и минусы.
1. В силу того, что PHP -- динамический язык, то не совсем понятно, что значат аргументы (по мне, синтаксис с $ и лямбда -- очень некрасивый).
2. Легко допустить ошибку из-за отсутствия типизации.
3. PHP -- не лучший выбор.

Есть еще момент, что есть мнение, что все манипуляции с данными, должны происходить непосредственно в БД. Возможно и правда все функции можно перенести в Postgres,
но тогда у нас будет 30+ функций, которые довольно тяжело будет тестировать.


2.
