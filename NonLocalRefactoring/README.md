# Нелокальные изменения проекта

Сначала описывается "первичный" вариант проекта и как к нему пришли. Далее описываются изменения проекта.
Дисклемейр: в основном приведены примеры, когда изменение дизайна касаются БД, то есть в нижеприведенных случаях большинство функций работают с данными в PL\SQL, а не на сервере, и эти функции я переношу в код PHP. Сталкивался со мнением, что работа с данными должна воспроизводиться в БД. Я не уверен, что это верный подход, в силу отсутствия опыта работы над большими проектами, могу ошибаться.

1. Первый пример.

Как было изначально: имеется проект, который занимается прогнозированием финансовых показателей сервисов. Сервисы распределены по двум БД -- назовем их А и Б.
Из этих БД берутся некоторые входные данные. Также имеются алгоритмы для прогнозирования того или иного сервиса. При расчете прогнозизования финансовых показателей,
финальный результат помещался в таблицу.
Но имеется общий алгоритм для формирования результата и назовем его Ф_ОБЩИЙ_ПРОГНОЗ:
1. Посчитать финанса Ф1. 
2. Посчитать финансы Ф2.
3. Посчитать финансы Ф3.
4. Посчитать финансы Фn и вывести результат.

Архитектура и дизайн приложения выглядел следующим образом:
1. Берем актуальные сервисы из БД.
2. Берем входные данные для сервисов.
3. К каждому сервису применяется определенный алгоритм. Возможна ситуация, когда для некоторых сервисов нужно было брать дополнительные данные из БД.
4. Выводим результат в финальную таблицу.

Изначально было несколько PL/SQL функций, которые рассчитывали финансовые показатели. Затем, по мере того, как добавлялись новые сервисы и новые спецификации
по прогнозированию, код был перенесен на PHP. 
В PHP алгоритм был следующий: класс Service имел метод для рассчета финансов. При этом, по мере развития проекта, были созданы множество Helper-подобных классов,
которые помогали рассчитывать показетели по изощренным алгоритмам.
Стоит сказать, что многие сервисы имели похожий алгоритм для рассчета, а некоторые -- совершенно отличающиеся. Т.е. общий алгоритм прогнозирования один, но как высчитываются
промежуточные данные (промежуточные алгоритмы) могут координально отличаться.
Стоит сказать, что используемая БД -- Postgres, и будь там пакеты, как в Oracle MySQL, то можно было бы просто расскидать функции по пакетам.

В итоге, часть кода была на PL/SQL, часть кода в PHP, и все довольно тяжело поддерживается.


Как можно изменить:
 
Во-первых выделим трудности проекта:
1. Часть кода, которая по-смыслу выполняют одну работу, разбросана в PL/SQL и в PHP, из-за чего сложнее поддерживать проект.
2. Код имеет множества недоклассов, которые нужно только для единичных случаев. (MathHelper, DateTimeHelper, SQLHelper и т.д.)
3. Забор данных из БД может происходить в разных момент (то есть в процессе рассчета), что, как мне кажется, не есть хорошо.

Тут, на мой взгляд, хорошо бы подошла функциональная парадигма:
1. У нас имеется общий алгоритм прогнозирования -- Ф_ОБЩИЙ. Можно создать функцию finance_forecast.
2. finance_forecast состоит из несколький шагов Ф, для каждого из которого имеется своя функция calculate_finance_type1.

Выглядит примерно следующий образом:
```php
//$service -- соответствующий сервис
//$listOfFunctions -- список лямбда-функций, которые нужны для вычислений.
const $servicesFunctions = (1, array($lambda1, $lambda2...));

function calculate_forecast($servicesFunctions)
{
    calculate_finance_type1($service, $listOfFunctions[0]);
    calculate_finance_type2($service, $listOfFunctions[1]);
    ...
    calculate_finance_typen($service, $listOfFunctions[n-1]);
};
```
Далее, создадим для функции для рассчета непосредственно финансов для каждого шага. Тут стоит мыслить не "как данный сервис рассчитывается финансы на шаге Фk',
а "какие алгоритмы имеются для рассчета финансов". 

Создаем модуль/директорию/иерархию "FinanceAlgorithms". Самый "верхний" уровень будет следующим:

```php

namespace FinanceAlgorithms;

  function calculate_finance_type1($input_data, $lambdaHowToCalc)
  {

  };

  function calculate_finance_type2($input_data, $lambdaHowToCalc)
  {

  };

//...
```

Далее, мы создаем непосредственно функции $lambdaHowToCalc. Выглядеть финальный результат будет следующим образом:
```php
//Получаем все данные из БД, заносим их в const переменные. Далее создает $serviceFunctions.
const $servicesFunctions = (1 => $calculateForService1($someFunction($someArg1, $someArg2)),
                            2=>...);
    
function calculate_forecast($service, $listOfFunctions)
{
    calculate_finance_type1($service, $listOfFunctions[0]);
    calculate_finance_type2($service, $listOfFunctions[1]);
    ...
    calculate_finance_typen($service, $listOfFunctions[n-1]);
};

foreach($servicesFunctions as $service => function)
{
  calculate_forecast($service, $function);
}

```

Таким образом:
1. Мы уберем функции из PL/SQL. У нас будет храниться рассчет в едином месте.
2. Сокращена кодовая база на 7-10 классов (хелперы нам не нужны, для этого есть функции).
3. Довольно гибкая архитекута (для рассчета нового сервиса добавляем новую функцию).
4. Легко тестировать.

Но тут имеются и минусы.
1. В силу того, что PHP -- динамический язык, то не совсем понятно, что значат аргументы (по мне, синтаксис с $ и лямбда -- очень некрасивый).
2. Легко допустить ошибку из-за отсутствия типизации.
3. PHP -- не лучший выбор.

Есть еще момент, что есть мнение, что все манипуляции с данными, должны происходить непосредственно в БД. Возможно и правда все функции можно перенести в Postgres,
но тогда у нас будет 30+ функций, которые довольно тяжело будет тестировать.

================================================================================

2. Второй пример.

Как было изначально: имеется внутрикорпоративный проект, который является аналогом excel'a. Имеется отчет, который состоит из блоков (блоки имеют уникальное название), которые содержат внутри себя строки и столбцы, которые заполняются некоторыми данными. В ячейку можно заносить не только выражения, но и формулы. То есть, у нас имеются объекты:
1. Выражения
2. Формулы
3. Иные объекты (файлы и т.д.)

Формулы могут ссылаться на ячейки из других блоков.

Ситуация такая, что все хранится в БД -- рассчет формул, создание, хранение и, что мне не нравится -- валидация формул. Работает это все сейчас следующим
образом -- проверяется валидность формулы как математического выражения, далее проверяет, что в формуле отсутствует цикличность (ячейка я ссылается на ячейку Б, а ячейка Б -- на ячейку), поскольку, если мы будет раскрывать формулы, то займем рекурсией всю ОЗУ.

Блоки также содержат строки-показатели. Данные показатели хранятся в виде массива в PHP. То есть, для рассчета формулы для некоего показателя, нужно лезть то в БД, то в PHP. 

Отчеты хранятся в виде JSON в Postgres.

Как можно изменить:

Тут на самом деле вся ситуация решается, как мне кажется, красиво следующим образом:

Создаем АТД-шки Блок, Ячейка, ДеревоВыражений и Показатель. Когда поступает на API данные, допустим с формулой, то создаем структуру данных "Дерево выражений", с помощью которого и проверяем ацикличность формулы. Получив выражение, состоящее исключительно из цифр, мы можем рассчитать соответствующую  формулу для Конкретного показателя.

Вопрос в создании и сохранении отчета. Я бы использовал Mongo, поскольку, если нам потребуется лишь некоторая информация из отчета, то делать запрос
в Postgres'e по полю JSON будет работать медленее. Причем хранить не целиком отчет, а только блоки, из которых отчет состоит, тем самым можно будет создавать новый отчет на основе существующих блоков. Несмотря на то, что связь между сущностью Блок и Показатель -- многие ко многим, тут все же лучше прибегнуть в свойству Mongo, а именно локальность данных -- намного проще хранить названия показателя.

Получается следующая картина: некий сформированный отчет отправляется по API в виде JSON'a. Мы получаем все формулы, которые легко валидируем с помощью структуры данных "дерево выражений" и рассчитываем. Сформировав отчет, мы складываем все в Mongo.

В данном примере, вопрос больше в том, что даст нам подобное изменение. 
Во-первых, в Postgres'е PL/SQL не будет функций, которые намного проще реализовать в PHP.
Во-вторых, в Postgres'e не будет таблиц с колонкой Json, которая хранит огромный json. Если мы захотим получить определенные показатели, то запросы будут
неудобочитаемые и неэффективными.
В-третьих, вносить изменения в PL\SQL намного сложнее, нежели в PHP.

===========================
Вывод:
По мере анализа проектов, попыток их "переделать", я приходил к выводу, что основная причина, по которой дизайн, который получается изначально -- далеок не лучший, и в процессе жизни проекта дизайн его модулей приходится переделывать -- ошибка в выборе инструмента. В моем понимании и на наличии собственного опыта, я вижу это как:

1. Выбрана не лучшая БД.
2. Выбран не лучший способ работы с данными (структура модуля, как обрабатываются данные).
3. В целом проектные решения неудачные.

В случае с БД еще можно обойтись относительно малой кровью (миграция данных). 
Второй пункт -- рефакторинг, переосмысление модулей в виде "выпускаем версию 2.0". Возможно, в большинстве случаев обходится все "переписыванием" классов, но, если используется не тот инструмент, то можно быстро упереться в потолок.
С 3-им пунктом все гораздо печальнее -- и скорее 1 и 2-ой пункт есть следствие этого. Но тут мне сложно что сказать, так как не проектировал коммерческие проекты.


